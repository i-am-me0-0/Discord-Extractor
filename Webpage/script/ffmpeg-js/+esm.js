/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@ffmpeg/ffmpeg@0.11.6/src/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import"./+esm-runtime.js";function e(e){if(e.__esModule)return e;var r=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(e).forEach((function(t){var o=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,o.get?o:{enumerable:!0,get:function(){return e[t]}})})),r}var r="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{};"function"==typeof r.setTimeout&&setTimeout,"function"==typeof r.clearTimeout&&clearTimeout;function t(e,r){this.fun=e,this.array=r}t.prototype.run=function(){this.fun.apply(null,this.array)};var o=r.performance||{};o.now||o.mozNow||o.msNow||o.oNow||o.webkitNow;new Date;var a={name:"@ffmpeg/ffmpeg",version:"0.11.6",description:"FFmpeg WebAssembly version",main:"src/index.js",types:"src/index.d.ts",directories:{example:"examples"},scripts:{start:"node scripts/server.js","start:worker":"node scripts/worker-server.js",build:"rimraf dist && webpack --config scripts/webpack.config.prod.js","build:worker":"rimraf dist && webpack --config scripts/webpack.config.worker.prod.js",prepublishOnly:"npm run build",lint:"eslint src",wait:"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js",test:"npm-run-all -p -r start test:all","test:all":"npm-run-all wait test:browser:ffmpeg test:node:all","test:node":"node node_modules/mocha/bin/_mocha --exit --bail --require ./scripts/test-helper.js","test:node:all":"npm run test:node -- ./tests/*.test.js","test:browser":"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000","test:browser:ffmpeg":"npm run test:browser -- -f ./tests/ffmpeg.test.html"},browser:{"./src/node/index.js":"./src/browser/index.js"},repository:{type:"git",url:"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git"},keywords:["ffmpeg","WebAssembly","video"],author:"Jerome Wu <jeromewus@gmail.com>",license:"MIT",bugs:{url:"https://github.com/ffmpegwasm/ffmpeg.wasm/issues"},engines:{node:">=12.16.1"},homepage:"https://github.com/ffmpegwasm/ffmpeg.wasm#readme",dependencies:{"is-url":"^1.2.4","node-fetch":"^2.6.1","regenerator-runtime":"^0.13.7","resolve-url":"^0.2.1"},devDependencies:{"@babel/core":"^7.12.3","@babel/preset-env":"^7.12.1","@ffmpeg/core":"^0.11.0","@types/emscripten":"^1.39.4","babel-eslint":"^10.1.0","babel-loader":"^8.1.0",chai:"^4.2.0",cors:"^2.8.5",eslint:"^7.12.1","eslint-config-airbnb-base":"^14.1.0","eslint-plugin-import":"^2.22.1",express:"^4.17.1",mocha:"^8.2.1","mocha-headless-chrome":"^2.0.3","npm-run-all":"^4.1.5","wait-on":"^5.3.0",webpack:"^5.3.2","webpack-cli":"^4.1.0","webpack-dev-middleware":"^4.0.0"}};var s={corePath:`./ffmpeg-core.js`};let i=!1,n=()=>{};var f=(e,r)=>{n({type:e,message:r}),i&&console.log(`[${e}] ${r}`)};var l=e=>`\ncreateFFmpegCore is not defined. ffmpeg.wasm is unable to find createFFmpegCore after loading ffmpeg-core.js from ${e}. Use another URL when calling createFFmpeg():\n\nconst ffmpeg = createFFmpeg({\n  corePath: './ffmpeg-core.js',\n});\n`;const p=async(e,r)=>{f("info",`fetch ${e}`);const t=await(await fetch(e)).arrayBuffer();f("info",`${e} file size = ${t.byteLength} bytes`);const o=new Blob([t],{type:r}),a=URL.createObjectURL(o);return f("info",`${e} blob URL = ${a}`),a};var c=Object.freeze({__proto__:null,defaultOptions:s,getCreateFFmpegCore:async({corePath:e,workerPath:r,wasmPath:t})=>{if("undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope){if("string"!=typeof e)throw Error("corePath should be a string!");const o=new URL(e,import.meta.url).href,a=await p(o,"application/javascript"),s=await p(void 0!==t?t:o.replace("ffmpeg-core.js","ffmpeg-core.wasm"),"application/wasm"),i=await p(void 0!==r?r:o.replace("ffmpeg-core.js","ffmpeg-core.worker.js"),"application/javascript");return"undefined"==typeof createFFmpegCore?new Promise((e=>{if(globalThis.importScripts(a),"undefined"==typeof createFFmpegCore)throw Error(l(o));f("info","ffmpeg-core.js script loaded"),e({createFFmpegCore:createFFmpegCore,corePath:a,wasmPath:s,workerPath:i})})):(f("info","ffmpeg-core.js script is loaded already"),Promise.resolve({createFFmpegCore:createFFmpegCore,corePath:a,wasmPath:s,workerPath:i}))}if("string"!=typeof e)throw Error("corePath should be a string!");const o=new URL(e,import.meta.url).href,a=await p(o,"application/javascript"),s=await p(void 0!==t?t:o.replace("ffmpeg-core.js","ffmpeg-core.wasm"),"application/wasm"),i=await p(void 0!==r?r:o.replace("ffmpeg-core.js","ffmpeg-core.worker.js"),"application/javascript");return"undefined"==typeof createFFmpegCore?new Promise((e=>{const r=document.createElement("script"),t=()=>{if(r.removeEventListener("load",t),"undefined"==typeof createFFmpegCore)throw Error(l(o));f("info","ffmpeg-core.js script loaded"),e({createFFmpegCore:createFFmpegCore,corePath:a,wasmPath:s,workerPath:i})};r.src=a,r.type="text/javascript",r.addEventListener("load",t),document.getElementsByTagName("head")[0].appendChild(r)})):(f("info","ffmpeg-core.js script is loaded already"),Promise.resolve({createFFmpegCore:createFFmpegCore,corePath:a,wasmPath:s,workerPath:i}))},fetchFile:async e=>{let r=e;if(void 0===e)return new Uint8Array;if("string"==typeof e)if(/data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(e))r=atob(e.split(",")[1]).split("").map((e=>e.charCodeAt(0)));else{const t=await fetch(new URL(e,import.meta.url).href);r=await t.arrayBuffer()}else(e instanceof File||e instanceof Blob)&&(r=await(t=e,new Promise(((e,r)=>{const o=new FileReader;o.onload=()=>{e(o.result)},o.onerror=({target:{error:{code:e}}})=>{r(Error(`File could not be read! Code=${e}`))},o.readAsArrayBuffer(t)}))));var t;return new Uint8Array(r)}}),m=e(c);const{defaultArgs:d,baseOptions:g}={defaultArgs:["./ffmpeg","-nostdin","-y"],baseOptions:{log:!1,logger:()=>{},progress:()=>{},corePath:""}},u=(e,r)=>{const t=e._malloc(r.length*Uint32Array.BYTES_PER_ELEMENT);return r.forEach(((r,o)=>{const a=e.lengthBytesUTF8(r)+1,s=e._malloc(a);e.stringToUTF8(r,s,a),e.setValue(t+Uint32Array.BYTES_PER_ELEMENT*o,s,"i32")})),[r.length,t]},{defaultOptions:h,getCreateFFmpegCore:w}=m,{version:b}=a,F=Error("ffmpeg.wasm is not ready, make sure you have completed load().");const y=(e={})=>{const{log:r,logger:t,progress:o,...a}={...g,...h,...e};let s=null,i=null,n=null,f=null,l=!1,p=()=>{},c=r,m=o,y=0,v=0,j=!1,P=0;const k=(e,r)=>{p({type:e,message:r}),c&&console.log(`[${e}] ${r}`)},E=e=>{const[r,t,o]=e.split(":");return 60*parseFloat(r)*60+60*parseFloat(t)+parseFloat(o)},C=({type:e,message:r})=>{k(e,r),((e,r)=>{if("string"==typeof e)if(e.startsWith("  Duration")){const t=e.split(", ")[0].split(": ")[1],o=E(t);r({duration:o,ratio:P}),(0===y||y>o)&&(y=o,j=!0)}else if(j&&e.startsWith("    Stream")){const r=e.match(/([\d.]+) fps/);if(r){const e=parseFloat(r[1]);v=y*e}else v=0;j=!1}else if(e.startsWith("frame")||e.startsWith("size")){const t=e.split("time=")[1].split(" ")[0],o=E(t),a=e.match(/frame=\s*(\d+)/);if(v&&a){const e=parseFloat(a[1]);P=Math.min(e/v,1)}else P=o/y;r({ratio:P,time:o})}else e.startsWith("video:")&&(r({ratio:1}),y=0)})(r,m),(e=>{"FFMPEG_END"===e&&null!==n&&(n(),n=null,f=null,l=!1)})(r)};return k("info",`use ffmpeg.wasm v${b}`),{setProgress:e=>{m=e},setLogger:e=>{p=e},setLogging:e=>{c=e},load:async()=>{if(k("info","load ffmpeg-core"),null!==s)throw Error("ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.");{k("info","loading ffmpeg-core");const{createFFmpegCore:e,corePath:r,workerPath:t,wasmPath:o}=await w(a);s=await e({mainScriptUrlOrBlob:r,printErr:e=>C({type:"fferr",message:e}),print:e=>C({type:"ffout",message:e}),locateFile:(e,r)=>{if("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope){if(void 0!==o&&e.endsWith("ffmpeg-core.wasm"))return o;if(void 0!==t&&e.endsWith("ffmpeg-core.worker.js"))return t}return r+e}}),i=s.cwrap(a.mainName||"proxy_main","number",["number","number"]),k("info","ffmpeg-core loaded")}},isLoaded:()=>null!==s,run:(...e)=>{if(k("info",`run ffmpeg command: ${e.join(" ")}`),null===s)throw F;if(l)throw Error("ffmpeg.wasm can only run one command at a time");return l=!0,new Promise(((r,t)=>{const o=[...d,...e].filter((e=>0!==e.length));n=r,f=t,i(...u(s,o))}))},exit:()=>{if(null===s)throw F;f&&f("ffmpeg has exited"),l=!1;try{s.exit(1)}catch(e){k(e.message),f&&f(e)}finally{s=null,i=null,n=null,f=null}},FS:(e,...r)=>{if(k("info",`run FS.${e} ${r.map((e=>"string"==typeof e?e:`<${e.length} bytes binary file>`)).join(" ")}`),null===s)throw F;{let t=null;try{t=s.FS[e](...r)}catch(t){throw"readdir"===e?Error(`ffmpeg.FS('readdir', '${r[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`):"readFile"===e?Error(`ffmpeg.FS('readFile', '${r[0]}') error. Check if the path exists`):Error("Oops, something went wrong in FS operation.")}return t}}}},{fetchFile:v}=m;var j={createFFmpeg:y,fetchFile:v},P=j.createFFmpeg,k=j.fetchFile;export{P as createFFmpeg,j as default,k as fetchFile};
//# source/MappingURL=/sm/709ee8f84d55d27b55fa813645f665a37dbf871d43d67aebb42f9e93ef463585.map //comment